<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<html xmlns="https://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Henry Zelenka - Intuitionistic type theory in a nutshell</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Henry Zelenka</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../resume.html">Resume</a>
                <a href="../archive.html">Blog</a>
            </div>
        </div>

        <div id="content">
            <h1>Intuitionistic type theory in a nutshell</h1>

            <div class="info">
    Posted on May  3, 2017
    
</div>

<p>Here are three apparent tautologies:</p>
<ul>
<li>If a proposition is not not true, it is true.</li>
<li>Either a proposition is true or it is not true.</li>
<li>If propositions A and B are not both true, one of them is false.</li>
</ul>
<p>These tautologies seem not just true, but <em>trivially</em> true. Their truth is so obvious as to be meaningless. They are <em>analytic</em> statements, like “all bachelors are unmarried men”.</p>
<p>I claim that these statements are not quite tautologies. There exists a system of logic in which they do not necessarily hold. Interactive theorem provers – most prominently Coq, but also Agda and Idris – subscribe to intuitionistic type theory, in which these three statements are – well, not exactly <em>false</em>, but not <em>true</em> either. We can prove them in certain instances, but they do not hold in general.</p>
<p>Denying double negation in particular often sounds nonsensical. Many research mathematicians I have spoken to have expressed shock and even offense that a double negative is not a positive in Coq. (As David Hilbert put it, “Dieses Tiertum non datur dem Mathematiker zu nehmen, wäre etwa, wie wenn man dem Astronomen das Ferhrohr oder dem Boxer den Gebrauch der Fäuste untersagen wollte”: to deny the mathematician double negation would be like to deny the astronomer the telescope or the boxer the fists. We’ll meet Hilbert again later; he’ll be wrong there, too.) In fact, in intuitionistic type theory, it is perfectly logical to leave these three axioms out, even a good idea.</p>
<p>A fundamental data structure in computer science is a linked list. A list is a container for some integer number of objects of the same type; a <em>linked</em> list is one where every element is either the end of the list or offers directions to the memory address of the next element. To get to the element in a linked list you want, you have to pass through each element ahead of it, like Indiana Jones jumping over the train cars.</p>
<p>Linked lists exist in both C++ and Haskell, but I think Haskell’s syntax for declaring new data types is prettier, and that’s all we ever need:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">List</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</code></pre></div>
<p>What I like about Haskell is that the meaning of code fragments tends to match intuition. The left side of the equality says what we’re declaring: namely, that for any type <code>a</code>, we can define a data type <code>List a</code>. We have <code>List Int</code>s, <code>List String</code>s, and even <code>List (List (List Char))</code> (lists of lists of lists of chars). The right side of the equality tells us how to make lists concretely. Namely, a list is either empty, or it’s an element of type <code>a</code> attached to another list. For example, we have the list <code>Cons 3 (Cons 2 (Cons 1 Nil))</code> – a <code>List Int</code> containing a <code>3</code>, a <code>2</code> and then a <code>1</code>.</p>
<p>Peano was an Italian mathematician who came up with the following, elegant definition of the natural numbers:</p>
<ul>
<li>Zero is a natural number.</li>
<li>For every natural number \( n \), the successor of that natural number, written \( S(n) \) and corresponding to \(n+1\) is also a natural number.</li>
</ul>
<p>That description sounds a lot like the Haskell definition of lists. The similarity is so obvious, we just <em>have</em> to write the Peano numbers as a Haskell data type:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Peano</span></code></pre></div>
<p><code>Zero</code> is now a Haskell variable of type <code>Peano</code>. So is <code>Succ (Succ Zero)</code>, representing 2, and so is <code>Succ (Succ (Succ (Succ (Succ Zero))))</code>, representing 5. Obviously representing natural numbers in this way quickly gets unwieldy, but bear with me.</p>
<p>By the way, a shorter and Haskellier way of writing “<code>Succ (Succ Zero)</code> has type <code>Peano</code>” is <code>Succ (Succ Zero) :: Peano</code>. This will come in handy later.</p>
<p>The greatest feeling in mathematics is recognizing that two seemingly unrelated concepts are actually related, or even the same thing. So it is with data types and mathematical axiomatizations. The Haskell definition of <code>List a</code>s exhaustively defines all valid <code>List a</code>s and the Peano definition of natural numbers exhaustively defines all valid natural numbers.</p>
<p>The Curry-Howard isomorphism says that <em>types are propositions, and propositions are types</em>. The type <code>Peano</code> we just defined is a proposition that we could paraphrase as: “natural numbers exist”. Each instance of <code>Peano</code> proves the proposition, in the same way that 2 proves that natural numbers exist. With Curry-Howard in mind, we could also pronounce <code>::</code> in Haskell as “is a proof of”, so that <code>Succ (Succ Zero) :: Peano</code> says “2 is a proof that natural numbers exist”.</p>
<p>Curry-Howard goes deeper still. It is often the case that trivialities are trivial under both interpretations. The trivial logical property of <em>modus ponens</em> says that, if we have an implication \( A \implies B \) (read “A implies B”) and \( A \) is true, then \( B \) is true. In Haskell, if we have a function of type <code>a -&gt; b</code>, and we have a value of type <code>a</code>, we can get a value of type <code>b</code> by applying the function to the value.</p>
<p>These tentative steps into intuitionistic type theory are enough to recognize the key way it differs from classical logic. Classically, truth and falsity are a fundamental part of any proposition. In a sense, all there is to a proposition in classical logic is whether it’s true or false. That’s all we need to know to join propositions together with fun symbols like \( \implies \) and \( \iff \).</p>
<p>Intutionistic type theory is concerned with not only <em>if</em> a given proposition is true, but <em>why</em> it’s true – what its proof is. Proving a proposition amounts to defining an object fitting some specifications. Proofs are mathematical objects in intuitionistic type theory, just like integers or polynomials.</p>
<p>Axiomatizations are rarely as elegant as Peano’s definition of the natural numbers, but they are often more involved. Consider this axiomatization that defines what it means for one natural number to be less than or equal to another:</p>
<ul>
<li>Zero is less than or equal to all natural numbers.</li>
<li>If \( n \) is less than or equal to \( m \), then \( S(n) \) is less than or equal to \( S(m) \).</li>
</ul>
<p>The fact that this axiomatization <em>works</em> is not as obvious as it was with the Peano natural numbers. Take a moment to think about it, if you need to, and convince yourself that it’s impossible to derive, say, that two is less than or equal to one.</p>
<p>Again, it’s tempting to write a Haskell data type building off of the <code>Peano</code>s from earlier. Remember what we learned about the Curry-Howard isomorphism: to prove a proposition is to present a value having its type. Therefore we want to make an <code>LTE</code> type in Haskell such that we can present a value of type <code>LTE (Succ Zero) (Succ (Succ Zero))</code>, but not <code>LTE (Succ (Succ Zero)) (Succ Zero)</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">LTE</span> <span class="fu">???</span> <span class="fu">???</span> <span class="fu">=</span> <span class="dt">LTEZero</span> <span class="fu">???</span> <span class="fu">|</span> <span class="dt">LTESucc</span> <span class="fu">???</span></code></pre></div>
<p>I left some <code>?</code>s strewn about since there’s a lot going on in this data type that Haskell just can’t handle. Haskell’s type system forms a fuzzier overlay over the language. 2 and 65536 are obviously different as values, but they both have the type <code>Int</code>. In Haskell, a <code>-&gt;</code> is used for function types, so we have <code>neg :: Int -&gt; Int</code> for the function negating an integer: it takes an integer and maps it to another integer. In the Haskell version of <code>Peano</code> earlier, <code>Zero :: Peano</code> and <code>Succ :: Peano -&gt; Peano</code>, so that <code>Succ</code> was really just a function from <code>Peano</code>s to <code>Peano</code>s. Functions like <code>Succ</code> (called <em>data constructors</em>) are somewhat restricted in comparison to ones like <code>neg</code>, though. Functions like <code>neg</code> are allowed to <em>pattern match</em>, responding differently to different particular <code>Int</code>s. <code>Succ</code> needs to treat all <code>Peano</code>s equally.</p>
<p>What would be really nice would be to communicate to Haskell that the <code>LTE</code> relation just isn’t valid for all ordered pairs of <code>Peano</code>s. Problem is, a function – and data constructors are indeed functions – need to map <em>all</em> valid inputs to outputs. Partial functions just aren’t really functions until you restrict the domain.</p>
<p>One solution is to have <code>LTE</code> to be a function from two <code>Peano</code>s that returns a type. Then we could ensure that we can only make a value of type <code>LTE</code> when it is justified to do so. In Haskell, that’s impossible. Like the shadows dancing on the wall in Plato’s cave, Haskell types are doomed to forever see values in silhouette. All Haskell really do is tell the compiler when to reject a program.</p>
<p>We need a programming language where types and values are on the same footing, where they can live and laugh together in harmony. We need Idris.</p>
<p>(Or any language with dependent types, but I like Idris.)</p>
<p>We can define <code>Peano</code>s in Idris exactly the same as we did in Haskell:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Peano</span> <span class="fu">=</span> <span class="dt">Zero</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Peano</span></code></pre></div>
<p>Declaring the <code>LTE</code> type is a breeze, too:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">LTE</span> <span class="ot">:</span> <span class="dt">Peano</span> <span class="ot">-&gt;</span> <span class="dt">Peano</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="kw">where</span>
  <span class="dt">LTEZero</span> <span class="ot">:</span> (m <span class="ot">:</span> <span class="dt">Peano</span>) <span class="ot">-&gt;</span> <span class="dt">LTE</span> <span class="dt">Zero</span> m
  <span class="dt">LTESucc</span> <span class="ot">:</span> <span class="dt">LTE</span> m n <span class="ot">-&gt;</span> <span class="dt">LTE</span> (<span class="dt">Succ</span> m) (<span class="dt">Succ</span> n)</code></pre></div>
<p>Unlike in Haskell, Idris allows data constructors to more carefully define the specifications (the <em>type signature</em> of data constructors). Note that has-type-of is spelled <code>:</code> instead of <code>::</code> in Idris. <code>LTEZero</code> says: “for any Peano natural number, I can give you a proof that zero is less than that natural number”. Simple as that is, it’s something Haskell just can’t do. Haskell can’t map a natural number to a type representing zero being less than the number. That would require types and values to interact.</p>
<p><code>LTESucc</code> is a bit more complicated, but I’m sure you can understand it! It says: “if you give me a proof that one natural number is less than or equal to another, I can prove to you that the successor of the first is less than or equal to the successor of the second”. That’s a mouthful, but it’s obviously true when you read it carefully.</p>
<p>By the way, here’s a more formal way of writing out the mathematical axiomatization of less-than-or-equal-to:</p>
<ul>
<li>\( \forall n \in \mathbb{N}, 0 \leq n \)</li>
<li>\( \forall n, m \in \mathbb{N}, n \leq m \implies S(n) \leq S(m) \)</li>
</ul>
<p>See how closely it parallels the <code>LTE</code> type?</p>
<p>We can fire up the Idris command line interpreter and try out the data constructors for LTE live:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="dt">Idris</span><span class="fu">&gt;</span> <span class="dt">LTESucc</span> (<span class="dt">LTESucc</span> (<span class="dt">LTEZero</span> <span class="dv">1</span>))
<span class="dt">LTESucc</span> (<span class="dt">LTESucc</span> <span class="dt">LTEZero</span>) <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">2</span> <span class="dv">3</span>
<span class="dt">Idris</span><span class="fu">&gt;</span> <span class="dt">LTESucc</span> (<span class="dt">LTEZero</span> <span class="dv">0</span>)
<span class="dt">LTESucc</span> <span class="dt">LTEZero</span> <span class="ot">:</span> <span class="dt">LTE</span> <span class="dv">1</span> <span class="dv">1</span></code></pre></div>
<p>After executing a line, Idris tells us the type of the result. Note how <code>LTESucc</code> and <code>LTEZero</code> are allowed to vary the <em>type</em> of their output depending on the particular <em>value</em> they receive. That’s an example of dependent types!</p>
<p>In intuitionistic type theory, we call a function from a value that returns a particular type a pi-type, often written with a fancy capital pi: \( \Pi \). \( \Pi \)-types, believe it or not, correspond to the phrase <em>for all</em> or \( \forall \) in conventional mathematics. \( \forall \) says in a purely mathematical context that, given any element of a set or a topologic space or what have you, we can prove that some property holds for that particular element. Since propositions are types, proving a property that varies based on the input is just a function from values to types!</p>
<p>\( \forall \) and \( \Pi \)-types are there to prove something for everything. Sometimes, though, we’re more interested in proving something holds true in just one specific case – say, if we want to come up with the prime factorization of a natural number, there’s clearly one and only one in every case. Proving something is true in just one case corresponds to the existential quantifier \( \exists \), pronounced “there exists”.</p>
<p>\( \exists \) is somewhat more challenging to describe in a type-theoretic context than \( \forall \), but we can absolutely do it! The operator <code>**</code> – two asterisks – embodies “there exists” in Idris. Consider the Archimedean property of the natural numbers, which says that, for any natural number, we can come up with a bigger natural number. We’d write this in logical notation as (by the way, read \(\ni\) as “such that”):</p>
<p>$$ \forall m \in \mathbb{N}, \exists n\in \mathbb{N} \ni m \leq n$$</p>
<p>To prove a theorem in Idris, you need to start by declaring a particular type explaining exactly what it is you want to prove. For the Archimedean property, it’s:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">archimedeanProperty</span> <span class="ot">:</span> (m <span class="ot">:</span> <span class="dt">Peano</span>) <span class="ot">-&gt;</span> (n <span class="ot">:</span> <span class="dt">Nat</span> <span class="fu">**</span> <span class="dt">LTE</span> m n)</code></pre></div>
<p>Read the type from left to right and it’s more or less the same as the logical version!</p>
<p>Remember that we prove a theorem by presenting a valid member of the type. Since <code>archimedeanProperty</code> is a function, we need to write a function and demonstrate to the typechecker that it does everything it’s supposed to. The details of this process are fascinating, but rather technical, so it’ll have to wait for a future blog post. (I’m sure you’re waiting on the edge of your seat).</p>
<p>We call types like this one \( \Sigma \)-types (that’s a capital Greek sigma). Concretely, \( \Sigma \)-types are mappings to ordered pairs where the type of the second element is allowed to depend on the type of the first; that’s so much more confusing than just saying that they correspond to \( \exists \), so let’s stay away from that definition!</p>
<p>There’s one last thing we need to define: negation. In classical logic, we could just say something like “the negation of \(A\) is defined to be the statement that is true precisely when \(A\) is false”. That definition isn’t exactly wrong, but it treats the truth or falsity of a proposition as a given. Either that, or it’s like we have superpowers: I can take a proposition and generate its exact opposite! In the proof-aware mathematics of type theory, where we prove a proposition by presenting an object embodying it, we can’t maintain constructiveness by defining negation this way.</p>
<p>A better idea is to define the following data type in Idris:</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="kw">data</span> <span class="dt">Void</span> <span class="kw">where</span></code></pre></div>
<p>That’s all! Wait, what? <code>Void</code> is a type that has no inhabitants! It’s a viable proposition, but a trivially false one, because it doesn’t have any proofs. In logical notation, we usually call <code>Void</code> \( False \) or \( \bot \) (pronounced “bottom”). I like the latter because it’s like a dead mathematician flipping you off.</p>
<p><code>Void</code> feels a bit like cheating, I admit, but it’s quite useful. If we want to embody the negation of some type – say <code>SqrtTwoIsRational</code> – we can just write <code>SqrtTwoIsRational -&gt; Void</code>. <code>SqrtTwoIsRational -&gt; Void</code> says “if I get a proof that the square root of two is rational, then I can return a proof of bottom”. There are, of course, <em>no</em> proofs of \( \bot \), so that type is equivalent to demonstrating to the compiler that <code>SqrtTwoIsRational</code> has no proofs either. The only way to do something impossible is to condition it on something impossible happening.</p>
<p>That definition of negation obeys <em>most</em> of the expected ones. For instance, the logical principle of <em>ex false quodlibet</em> says that, if we prove something contradictory, then it implies anything. If pigs fly, then London is the capital of Germany. Similarly, it’s possible to write a type-checking Idris function from <code>Void</code> to any other type. Writing a valid function amounts to coming up with a value in the return type for every value in the input type. If the input type is <code>Void</code>, “every value in the input type” is precisely nothing, so we’re done before we even started!</p>
<p>The key property that our form of negation doesn’t obey is double negative elimination. It does hold in constructive logic that \(A \implies \neg \neg A \). Here’s the proof: suppose we have a proof of the proposition \( A \), call it \( a \). We need to prove \( (A \implies \bot) \implies \bot \). To prove that implication, suppose we have a proof of \( A \implies \bot\). Then we can apply that implication to \( a \) from earlier and we have a value of type \( \bot \), which is exactly what we needed.</p>
<p>Double negative elimination – \( \neg \neg A \implies A \) – does not necessarily hold! Suppose we have a proof of \( \neg \neg A \), which expands to \( (A \implies \bot) \implies \bot \). If the implication of \( A \) to \( \bot \) implies \( \bot \), then, in a sense, there must exist some proof of \( A \) somewhere – but in the proof-conscious mathematics of type theory, there are no ambient proofs. Proving \( A \) requires us to come up a value of type \( A \), and \( (A \implies \bot) \implies \bot \) tells us nothing about what a value of type \( A \) looks like.</p>
<p>There were two other seeming tautologies I mentioned at the top of the post that don’t hold in type theory. First, that a proposition is either true or not true. In type theory, proving “A or B” obliges you to present a value of type \( A \) or a value of type \( B \). Thus proving \( A \vee \neg A \) says we are always capable of proving a statement true or false. That isn’t true until every unsolved problem in mathematics is solved, which is actually impossible anyway. I blame Kurt Gödel.</p>
<p>Second, that if \( A \) and \( B \) are not both true, then either \( A \) is not true or \( B \) is not true. We’d write this as \( \neg (A \wedge B) \implies \neg A \vee \neg B \). To prove the conclusion true, we’d need to decide <em>which</em> of \( A \) and \( B \) is not true. One of them needs to be, clearly, but we can’t decide which with any sort of regularity.</p>
<p>You may still feel that intuitionistic type theory is deficient if it can’t establish these intuitive truths. It may help to consider incompleteness.</p>
<p>At the beginning of the 20th century, mathematics was experiencing a <em>Grundlagenkrise</em> or foundational crisis. Mathematicians were unsure what to base their work on – how all mathematical knowledge to date could be unified. Hilbert sought to come up with a list of axioms from which the rest of modern mathematics could be derived – short enough not to contradict itself, but thorough enough to cover everything.</p>
<p>Kurt Gödel rather rudely proved that what Hilbert was trying to do was impossible!</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="https://jaspervdj.be/hakyll">Hakyll</a>;
            theme by <a href="https://github.com/katychuang/hakyll-cssgarden">katychuang</a>
        </div>
    </body>
</html>
